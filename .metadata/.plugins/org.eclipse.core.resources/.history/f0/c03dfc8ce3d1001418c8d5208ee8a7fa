package edu.jhu.cs.wilkes.cs335.assignment4.traditional;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class DecisionTreeNode {

	
	private int decisionNumber;
	private List<Integer> remainingAttributes;
	private Map<String,DecisionTreeNode> children;
	private DecisionTreeNode parent;
	private List<CaseForClassification> toBeClassified;
	private String classification;
	
	/**
	 * Constructor for a decision tree node.
	 * @param decisionNumber the attribute index to be used
	 * @param remainingAttributes the list containing all the other attribute indices which are unused
	 * @param parent the node which created this node
	 * @param toBeClassified the cases which reach this decision node.
	 */
	public DecisionTreeNode(int decisionNumber,
			List<Integer> remainingAttributes, DecisionTreeNode parent,
			List<CaseForClassification> toBeClassified) {
		
		this.decisionNumber = decisionNumber;
		this.remainingAttributes = remainingAttributes;
		this.parent = parent;
		this.toBeClassified = toBeClassified;
		this.classification = "";
		
		
		// check if all the remaining cases to be classified are the same.
		CaseForClassification toCheck = this.toBeClassified.get(0);
		for (int i = 0; i < this.toBeClassified.size(); i++) {
			if (!toCheck.getClassification().equals(this.toBeClassified.get(i).getClassification())) {
				this.classification = null;
			}
		}
		// if they are all the same, then the classification of this node is that classification.
		if (this.classification != null) {
			this.classification = toCheck.getClassification();
			this.children = null;
			return;
		}
		
		// removes this attribute from those in the list.
		if (this.remainingAttributes.contains(this.decisionNumber)) {
			this.remainingAttributes.remove(this.remainingAttributes.indexOf(this.decisionNumber));
		}
		
		// figure out the children.
		
	}
	

	
	/**
	 * Gets the attribute number which is being used as the decision for this node
	 * @return the identifier index number for the attribute used at this node.
	 */
	public int getDecisionNumber() {
		return decisionNumber;
	}


	/**
	 * getter method to find the parent node
	 * @return the parent
	 */
	public DecisionTreeNode getParent() {
		return parent;
	}


	/**
	 * Returns the list of attributes which can still be investigated
	 * @return the remainingAttributes
	 */
	public List<Integer> getRemainingAttributes() {
		return remainingAttributes;
	}


	/**
	 * Gets the list of pointers to the children of this node.
	 * @return the children
	 */
	public Map<String, DecisionTreeNode> getChildren() {
		return children;
	}


	/**
	 * gets the list of cases which are found at this node.
	 * @return the toBeClassified
	 */
	public List<CaseForClassification> getToBeClassified() {
		return toBeClassified;
	}


	/**
	 * Method used to split the remaining cases based on a specified attribute index.  
	 * @param attributeIndex the index on which we are splitting
	 * @return a list of lists, with each element of the top level list representing a different
	 * value for the attribute index being explored, and is a list of all elements who have that value. 
	 */
	private List<List<CaseForClassification>> separateChildren(int attributeIndex) {
		List<List<CaseForClassification>> toReturn = new ArrayList<List<CaseForClassification>>();
		for (CaseForClassification child : toBeClassified) {
			int i;
			// check all the lists of classifications we have found so far.
			for (i = 0; i < toReturn.size(); i++) {
				if (child.getIdentifierAtIndex(attributeIndex).equals(
						toReturn.get(i).get(0).getIdentifierAtIndex(attributeIndex))) {
					toReturn.get(i).add(child);
					break;	
				}
			}
			// if this value of the specified index has not yet been found, put in a new list for this type.
			if (i >= toReturn.size()) {
				toReturn.add(new ArrayList<CaseForClassification>());
				toReturn.get(i).add(child);
			}
		}
		return toReturn;
	}
	
	// TODO need to add method to check a CFC on this decision tree node.
	
}
